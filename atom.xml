<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[狂奔的蜗牛]]></title>
  <link href="http://bgallon.github.io/atom.xml" rel="self"/>
  <link href="http://bgallon.github.io/"/>
  <updated>2016-09-03T12:05:00+08:00</updated>
  <id>http://bgallon.github.io/</id>
  <author>
    <name><![CDATA[fishpan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IPC机制-Binder]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/14/ipcji-zhi-binder/"/>
    <updated>2016-08-14T10:43:45+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/14/ipcji-zhi-binder</id>
    <content type="html"><![CDATA[<p>Binder是进程间通讯的一种方式，Android开发中，Binder主要用于Service中，其中普通的service不涉及设计进程间通讯，我这里看下AIDL方式，看下整个的调用过程</p>

<!--more-->


<p>首先我们先创建aidl文件IDemoManager.aidl,<strong><em>注意</em></strong>在Android studio中使用aidl,需要单独放在一个文件夹下，名称为aidl,和java同目录，如图</p>

<p><img src="http://i1.piimg.com/567571/e946c4c0e24e3645.jpg" alt="" /></p>

<p>内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">xxx</span><span class="o">.</span><span class="na">xxx</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'><span class="kd">interface</span> <span class="nc">IDemoManager</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后进行编译，如下图</p>

<p><img src="http://i1.piimg.com/567571/38daf5235fd2f2e9.jpg" alt="" /></p>

<p>可以在build中发现自动生成的代码，这就是aidl要做的事情，工具根据我们写的aidl文件，编程成代码，当然你也可以不写aidl文件，自己写代码</p>

<p><img src="http://i1.piimg.com/567571/2896af883b845c00.jpg" alt="" /></p>

<p>下面我就来研究一下为我们生成的代码，这个才是最关键</p>

<hr />

<pre><code>public interface IDemoManager extends android.os.IInterface {
/**
 * Local-side IPC implementation stub class.
 */
public static abstract class Stub extends android.os.Binder implements com.fishpan.appliactions.IDemoManager {
    private static final java.lang.String DESCRIPTOR = "com.fishpan.appliactions.IDemoManager";

    /**
     * Construct the stub at attach it to the interface.
     */
    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    /**
     * Cast an IBinder object into an com.fishpan.appliactions.IDemoManager interface,
     * generating a proxy if needed.
     */
    public static com.fishpan.appliactions.IDemoManager asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof com.fishpan.appliactions.IDemoManager))) {
            return ((com.fishpan.appliactions.IDemoManager) iin);
        }
        return new com.fishpan.appliactions.IDemoManager.Stub.Proxy(obj);
    }

    @Override
    public android.os.IBinder asBinder() {
        return this;
    }

    @Override
    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
        switch (code) {
            case INTERFACE_TRANSACTION: {
                reply.writeString(DESCRIPTOR);
                return true;
            }
            case TRANSACTION_add: {
                data.enforceInterface(DESCRIPTOR);
                int _arg0;
                _arg0 = data.readInt();
                int _arg1;
                _arg1 = data.readInt();
                int _result = this.add(_arg0, _arg1);
                reply.writeNoException();
                reply.writeInt(_result);
                return true;
            }
        }
        return super.onTransact(code, data, reply, flags);
    }

    private static class Proxy implements com.fishpan.appliactions.IDemoManager {
        private android.os.IBinder mRemote;

        Proxy(android.os.IBinder remote) {
            mRemote = remote;
        }

        @Override
        public android.os.IBinder asBinder() {
            return mRemote;
        }

        public java.lang.String getInterfaceDescriptor() {
            return DESCRIPTOR;
        }

        @Override
        public int add(int a, int b) throws android.os.RemoteException {
            android.os.Parcel _data = android.os.Parcel.obtain();
            android.os.Parcel _reply = android.os.Parcel.obtain();
            int _result;
            try {
                _data.writeInterfaceToken(DESCRIPTOR);
                _data.writeInt(a);
                _data.writeInt(b);
                mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);
                _reply.readException();
                _result = _reply.readInt();
            } finally {
                _reply.recycle();
                _data.recycle();
            }
            return _result;
        }
    }

    static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
}

public int add(int a, int b) throws android.os.RemoteException;
</code></pre>

<hr />

<p>自动生成的代码有点乱，我们可以把它给格式化一下，可以看到编译工具为我们生成了一个接口IDemoManager,继承于IInterface，啥事也没干；一个add方法，一个静态的内部抽象类，继承与Binder，实现IDemoManager本身，我们来详细看看他的每一部分</p>

<ul>
<li>DESCRIPTOR Binder的唯一标识</li>
<li>asInterface 用于将服务端的Binder对象转换成客户端所需要的aidl接口类型的对象，注意我们可以根据代码看出，他有两个地方有return，第一个其实是当客户端和服务端属于同一个进程时，返回自己本身，第二个是返回了一个代理对象</li>
<li>asBinder 用于返回当前Binder对象</li>
<li>onTransact 这个方法运行在<strong><em>服务端</em></strong>，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交有此方法。服务端通过code，确定客户端要执行什么方法，从data获取参数，然后指定目标方法；执行完毕后就像reply中写入返回值(如果有返回值)</li>
<li>Proxy#add 此方法运行在客户端，当客户端调用此方法时，会输入型参数write进<em>data，输出型参数write进</em>reply,紧接着会调用transact方法来发起RPC请求，当前线程挂起；服务端的onTransact方法被调用，调用结束后，返回数据会在_reply中。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FramtentPagerAdapter和FramgentStatePagerAdapter的区别]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/14/framtentpageradapterhe-framgentstatepageradapterde-qu-bie/"/>
    <updated>2016-08-14T10:43:45+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/14/framtentpageradapterhe-framgentstatepageradapterde-qu-bie</id>
    <content type="html"><![CDATA[<p>平时还真的很少关心FramgmentStatsPagerAdpater和FragmentPagerAdapter，以前只是两者有区别，但是不是很清楚到底有啥区别，今天就特别写了一个demo，来研究了下两者的区别</p>

<!--more-->


<h4>FragmentStateViewPager</h4>

<p>很多资料都在说：这个适配器是实现多个fragment界面的滑动时非常有效，当Fragment对用户不可见时，整个fragment会被销毁，只会保存fragment的状态，更适合当fragment比较多的时候使用，而且消耗的资源更少:我写了段代码在Fragment的onCreate，onCreateView，onDestory,onDestoryView方法中打印日志，观察它的生命周期：
我进入activity一直滑动到第三个Fragment为止，日志如下</p>

<p><img src="http://i2.buimg.com/567571/235e5452e84d1730.jpg" alt="" /></p>

<p>通过日志我们可以发现：</p>

<ul>
<li>当进入Activity时，会创建两个Fragment</li>
<li>向右滑一下到1，创建第三个fragment</li>
<li>再向右滑一下到2，这个时候不仅仅都创建了一个fragment，而且还销毁了第一个fragment</li>
<li>再向右滑一下到3，这个时候同样，创建一个销毁一个</li>
</ul>


<p>可见，默认情况下没有设置viewPager的offscreenPageLimit属性时，当前fragment的保留总数最多是三个，及当前选中的fragment和选中左右两个fragment（可能没有），其它的fragment就会被销毁，并且还会保留销毁的fragment的状态，待重建时进行恢复（onSaveInstanceState方法），所以我觉得上边说的当fragment不可见时就会被销毁时错误的，严格的来讲应该是在缓存fragment之外的fragment会被销毁，<strong><em>并不是不可见就会被销毁</em></strong></p>

<h4>FragmentViewPager</h4>

<p>这个是ViewPager+Fragment常用的适配器，我们经常会使用，虽然常见我为了弄清楚有啥区别，同样做了一个实验，在生命周期打印日志，操作步骤和上边的FragmentStateViewPager一致，日志如下:</p>

<p><img src="http://i1.buimg.com/567571/3828d9ebb9dc03f8.jpg" alt="" /></p>

<p>从日志中我们可以发现，基本上和FragmentStateViewPager类似，但是其中缺少fragment销毁的操作，这就是他们的区别，fragmentStatePagerAdapter会把缓存之外的fragment销毁，而FragmentViewPager则不会，还会进行保留。</p>

<h4>总结</h4>

<p>相比之下，FragmentViewPager会更加流畅，而FragmentStateViewPager会更节省资源，对于fragment比较多的情况下我们可以使用FragmentStateViewPager，较少时使用FragmentViewPager更为妥当一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPC机制-多进程]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/13/ipcji-zhi-duo-jin-cheng/"/>
    <updated>2016-08-13T15:03:24+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/13/ipcji-zhi-duo-jin-cheng</id>
    <content type="html"><![CDATA[<p>一个应用默认只有一个进程，这个进程的名字就是应用的包名，进程是系统分配资源和调度的基本单位，每个进程都要有自己的资源和空间，其它程序不能任意访问当前进程的空间，系统给每个进程分配的空间会有限制。</p>

<!--more-->


<p>但是这都是默认情况下的事情，伟大的程序员是不会屈服一个进程的，我就弄出多个进程来玩玩；Android系统也是蛮大方的，你要多个，好，我来满足你，你可以指定一些组件运行在不同的进程中，只需指定组件的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  android:process
</span></code></pre></td></tr></table></div></figure>


<p>设置process属性的方式有两种：</p>

<ul>
<li>android:process=&ldquo;:remote&rdquo;,以冒号开头，冒号后边的字符是可以随意指定的。当然这只是一种缩写形式，全称应该是：包名+&ldquo;:remote"；这种形式表示该进程为当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中。</li>
<li>android:process=&ldquo;xxx.xxx"表示运行在以这个名称的全局进程中，其它应用可以通过shareUID和他跑在同一个进程中；</li>
</ul>


<p>虽然开启多进程是非常非常简单，但是有很多坑，一不小心就掉进去了：</p>

<ul>
<li>Application多次创建，启动多进程的生活，Application会被多次创建，在application中我们可以通过当前进程名字，来初始化数据，防止无必要的初始化</li>
<li>静态成员失效，各个进程是单独分配的内存，所以这里的静态成员变量将会失效</li>
<li>文件共享，多个进程同时访问一个文件时，可能造成文件损坏丢失等情况</li>
<li>断点调试的问题。调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPC机制-序列化]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/08/ipcji-zhi-xu-lie-hua/"/>
    <updated>2016-08-08T21:59:42+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/08/ipcji-zhi-xu-lie-hua</id>
    <content type="html"><![CDATA[<p>IPC（Inter-Process Cmmunication）进程间通讯，两个进程间如何交换数据。进程和线程是不一样的，我们可以认为进程包含线程。下面我就开始一步一步的熟悉如何进行进程间通讯。</p>

<!--more-->


<h4>序列化</h4>

<p>我们以往的开放的经验中或多或少的都接触过序列，Serializable、Parcelable两个接口我们总会与我们不期而遇，我们最常见的是当我们启动一个Activity时，需要传递一些复杂类型，这个时候我们就要通过序列化的方式进行传递。</p>

<h4>Serializable接口</h4>

<p>Serializables是Java提供的接口，其实它只是一个空接口什么都没有做，使用它实现序列化也是灰常简单，只需实现它就行。但是我们另外要做一件事，就是新加一个标识如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span><span class="o">{</span>
</span><span class='line'>      <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4640203801029274924L</span><span class="o">;</span>
</span><span class='line'>      <span class="kd">public</span> <span class="n">string</span> <span class="n">username</span><span class="o">;</span>
</span><span class='line'>      <span class="kd">public</span> <span class="n">string</span> <span class="n">userid</span><span class="o">;</span>
</span><span class='line'>      
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是的，记住一定要写上serialVersionUID这个字段，当然值不一定是这个，否者会有惊喜哦！！</p>

<p>如果你不指定serialVersionUID这个值，也照样能够完成序列化，但是某些情况下可能报异常！我们接下来就来捯饬捯饬这个字段是干嘛用的；这个字段是用来辅助序列化和反序列化的，序列化的数据只有serialVersionUID与当前要反序列化的类中的serialVersionUID保持一致，才能正常的反序列化；当进行序列化的时候会保存serialVersionUID的值，在反序列化的时候再去对比是否相等；在不指定值得情况下，系统会计算当前类的hash值给serialVersionUID，一旦类发生变化这个值就会变化，从而出现崩溃，当然如果你修改了类的名字或者字段的类型，那么也同样会抛出异常。</p>

<h4>Pacelable接口</h4>

<p>Pacelable是Android特有的一个接口，相对于Serializable,它实现起来稍微复杂一点。实例如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Parcelable</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">private</span> <span class="n">String</span> <span class="n">username</span><span class="o">;</span>
</span><span class='line'>      <span class="kd">private</span> <span class="n">String</span> <span class="n">userid</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="kd">protected</span> <span class="nf">User</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">username</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
</span><span class='line'>          <span class="n">userid</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Creator</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">CREATOR</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Creator</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>          <span class="nd">@Override</span>
</span><span class='line'>          <span class="kd">public</span> <span class="n">User</span> <span class="nf">createFromParcel</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>          <span class="nd">@Override</span>
</span><span class='line'>          <span class="kd">public</span> <span class="n">User</span><span class="o">[]</span> <span class="nf">newArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="k">return</span> <span class="k">new</span> <span class="n">User</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>      <span class="nd">@Override</span>
</span><span class='line'>      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">describeContents</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="nd">@Override</span>
</span><span class='line'>      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeToParcel</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">dest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">dest</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
</span><span class='line'>          <span class="n">dest</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">userid</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong><em>注意</em></strong>这里一定注意writeToParcel(Parcel dest, int flags)和User(Parcel in)中读取或储存属性的顺序呢（猛敲黑板状），先存先读；</p>

<h4>总结</h4>

<p>注意，注意，注意重要的事情说三遍，这是必考点，记好笔记啦；Parcelable的性能比Serializable要好，内存开销方面比较小，所以内存在传递数据时推荐Parcelable,比如activity间传递数据时；但是Serializble序列化方便，可用在保存或者网络传输的时候，另外Android不同版本Parcelable可能会不同，所以不建议用它进行持久化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity启动模式]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/05/activityqi-dong-mo-shi/"/>
    <updated>2016-08-05T23:01:49+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/05/activityqi-dong-mo-shi</id>
    <content type="html"><![CDATA[<p>launchmode是Android一个非常重要的概念，关系到Activity实例的创建和重用；但是他比较琐碎，好多细节需要注意，分清各个模式的具体含义，会让你更好的理解并掌握它。Activity的启动模式有standard、singleTop、singleTask、singleInstance四种，我们可以在声明activity组件时设置lanunchmode值指定启动模式。</p>

<!--more-->


<h4>Standed模式</h4>

<p>standard模式（标准模式）是activity默认的启动模式，此种模式下，没启动一次Activity都会重新创建一个Activity实例，一个任务栈中可以有多个实例，也许比较傻，哈哈，这就是默认的standard模式</p>

<h4>SingleTop模式</h4>

<p>栈顶复用模式，通过名字我们就可以知道它大概的意思，就是当启动的Activity在任务栈栈顶时，就不在重新创建一个Activity实例啦，直接复用就行了，这个时候要特别注意，他不会再重新执行以下onCreate、onStart、onResume生命周期方法，因为Activity此时的状态并没有发生变化；一般情况下，我们可能会在onCreate中去加载数据，那么现在onCreate不会重新调用了，我该如何加载新的数据呢？别着急，系统早就为我们想到这一点，这个时候系统会调用Activity中的onNewIntent方法，我们在这里重新加载展示数据；举个🌰：假如现在任务栈中有ABC三个Activity（A在栈底，C在栈顶），我们这里就认为ABC都是singleTop启动模式，此时如果启动C的话，任务栈中的Activity不会有任何变化，因为C就在栈顶，不需要重新再创一个C实例，如果现在启动B，那么栈中Activity为ABCB，具体为什么我就不多说啦。</p>

<h4>SingleTask模式</h4>

<p>栈内复用模式，这里是什么意思呢？就是要启动的Activity在任务重存在，不管在栈的什么位置，都不会重新创建新的实例，和singleTop模式类似，当栈中存在要启动的Activity时，只会调用此Activity的onNewIntent方法；比如现在我们要启动Activity A，如果当前任务中存在A，那么就会调用A中onNewIntent方法，如果不存A，就会重新创建Activity A,并压入栈中。举几个🌰🌰：</p>

<ul>
<li>任务栈S1中有ABC三个Activity，如果此时已SingleTask模式启动Activity D，其所需要的任务栈为S2，由于S2栈和Activity D都不存在，所以首先会创建一个新的任务栈s2,然后创建一个Activity D实例，放入S2中。</li>
<li>如果Activity D需要的任务栈为S1情况会怎样呢？此时由于任务栈已经存在，但是Activity D并不在任务栈中，所以会创建Activity D实例，并放到S1栈中</li>
<li>建设现在S1栈中有ABDC四个Activity，现在要以SingleTask模式启动Activity D，其所需要的任务栈为S1，那么此时由于S1和Activity D都存在了，所以不会重新创建，但是这时栈内的情况会变成什么样呢？答案是：ABD，那C去哪儿了？被销毁了！singleTask默认有clearTop效果，会把Activity D上的Activity出栈。</li>
</ul>


<h4>SingleInstance模式</h4>

<p>单实例模式，它和singleTask类似，但是有一点区别，就是只能单独在一个任务栈中</p>

<h4>任务栈</h4>

<p>前文一曾多次提到任务栈，任务栈就是一个具有栈结构的容器，可以防止多个Activity;当启动一个应用时，系统会创建一个task,来放置根Activity；默认情况下，Activity会放在同一个task中，如果启动一个新的Activity的就把它压入栈顶，按返回键就把栈顶的Activity的弹出task，之前的Activity的又被显示出来，如果此时task中没有Activity,将会回到桌面；另外应用之间的task是相互独立的，比如我启动应用A，回到桌面有启动应用B，我还可以回到桌面再次启动A，但是内容并不会发生变化，之前应用A中的task还依然保留着。</p>

<h4>affinity</h4>

<p>有时，Android需要知道一个Activity他所属的task，就是通过这个属性来确定的。默认情况下，affinity的值为应用的包名，我也可以通过taskaffinity进行设置，其有两个作用：</p>

<ul>
<li>根据affinity重新为Activity选择宿主task</li>
<li>启动singleTask的Activity，会根据affinity查找或者重新创建一个task</li>
</ul>


<h4>常见的flags</h4>

<ul>
<li>FLAG_ACTIVITY_NEW_TASK:当启动activity的intent中设置了此flag时，系统会寻找或者重新创建一个task来存放activity，寻找的依据就是activity的affinity，如过找到了一个task，则将此Activity放到这个task，如果找不到的话，就创建一个task，并把activity压入栈中，<strong><em>注意：</em></strong>如果同一个应用中的activity的taskaffinity使用的默认值或者设置的同一个值，在应用内使用这个标记是没有任何作用的，因为当前的task就是要找的task</li>
<li>FLAG_ACTIVITY_CLEAR_TOP：当启动的Activity的intent中设置了这个标记，如果栈中存在要启动的Activity，则会把此Activity之上的Activity出栈；例如在MainActivity启动SecondActivity，在SecondActivity启动ThirdActivity，此时在ThirdActivity中启动MainActivity并在启动的intent中增加FLAG_ACTIVITY_CLEAR_TOP标记，此时，SecondActivity，ThirdActivity将会出栈，MainActivity重新出现</li>
<li>FLAG_ACTIVITY_SINGLE_TOP:当要启动的Activity在task栈顶时，不会重新创建Activity，而是重用此Activity</li>
</ul>


<p>这里推荐几篇写的比较好的博客：</p>

<p><a href="http://blog.csdn.net/liuhe688/article/details/6761337">Activity的task相关</a></p>

<p><a href="http://blog.csdn.net/guolin_blog/article/details/41087993">Android任务和返回栈完全解析，细数那些你所不知道的细节 </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity生命周期（三）]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/02/activitysheng-ming-zhou-qi-(san-)/"/>
    <updated>2016-08-02T10:19:00+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/02/activitysheng-ming-zhou-qi-(san-)</id>
    <content type="html"><![CDATA[<p>上篇写到默认情况下系统会自动存储Activity的状态，也许你看到会马上实践一下，但是可能并没有得到预期的效果。</p>

<!--more-->


<h4>自动存储恢复状态-正确的姿势</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;RelativeLayout</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>  <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;match_parent&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;EditText</span>
</span><span class='line'>      <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
</span><span class='line'>        <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>        <span class="na">android:id=</span><span class="s">&quot;@+id/main_edit&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/RelativeLayout&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>OK,这样系统就可以保存EditText的状态啦</p>

<p><strong><em>注意：</em></strong>
必须设置id，系统才会帮我们保存控件的状态，否则不会有任何效果</p>

<h4>系统保存Activity的过程</h4>

<p>首先我们来看下Activity中的onSaveInstanceStat方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onSaveInstanceState</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">outState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">outState</span><span class="o">.</span><span class="na">putBundle</span><span class="o">(</span><span class="n">WINDOW_HIERARCHY_TAG</span><span class="o">,</span> <span class="n">mWindow</span><span class="o">.</span><span class="na">saveHierarchyState</span><span class="o">());</span>
</span><span class='line'>    <span class="n">Parcelable</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mFragments</span><span class="o">.</span><span class="na">saveAllState</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">outState</span><span class="o">.</span><span class="na">putParcelable</span><span class="o">(</span><span class="n">FRAGMENTS_TAG</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">getApplication</span><span class="o">().</span><span class="na">dispatchActivitySaveInstanceState</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">outState</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中方法中的第一句，调用了Window中的saveHierarchyState方法，我们知道Window是一个抽象类，那我们来看下Window的子类PhoneWindow中的saveHierarchyState的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Bundle</span> <span class="nf">saveHierarchyState</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span><span class="na">此处省略几句代码</span>
</span><span class='line'>  <span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">Parcelable</span><span class="o">&gt;</span> <span class="n">states</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">Parcelable</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="n">mContentParent</span><span class="o">.</span><span class="na">saveHierarchyState</span><span class="o">(</span><span class="n">states</span><span class="o">);</span>
</span><span class='line'>    <span class="n">outState</span><span class="o">.</span><span class="na">putSparseParcelableArray</span><span class="o">(</span><span class="n">VIEWS_TAG</span><span class="o">,</span> <span class="n">states</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span><span class="na">此处省略几句代码</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看重点，其它代码就不贴了，可以看到，调用mContentParent的saveHierarchyState,mContentView是一个ViewGroup，ViewGroup中没有这个方法，我看下父类View</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">saveHierarchyState</span><span class="o">(</span><span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">Parcelable</span><span class="o">&gt;</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">dispatchSaveInstanceState</span><span class="o">(</span><span class="n">container</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>直接调用了dispatchSaveInstanceState方法，注意这时我们应该看ViewGroup中dispatchSaveInstanceState方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">dispatchSaveInstanceState</span><span class="o">(</span><span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">Parcelable</span><span class="o">&gt;</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">dispatchSaveInstanceState</span><span class="o">(</span><span class="n">container</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">mChildrenCount</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">View</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="n">mChildren</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">View</span> <span class="n">c</span> <span class="o">=</span> <span class="n">children</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">((</span><span class="n">c</span><span class="o">.</span><span class="na">mViewFlags</span> <span class="o">&amp;</span> <span class="n">PARENT_SAVE_DISABLED_MASK</span><span class="o">)</span> <span class="o">!=</span> <span class="n">PARENT_SAVE_DISABLED</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="na">dispatchSaveInstanceState</span><span class="o">(</span><span class="n">container</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>大致做了两件事情，第一个调用本身的dispatchSaveInstanceState，遍历子View并调用子View的dispatchSaveInstanceState方法；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">dispatchSaveInstanceState</span><span class="o">(</span><span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">Parcelable</span><span class="o">&gt;</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">mID</span> <span class="o">!=</span> <span class="n">NO_ID</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mViewFlags</span> <span class="o">&amp;</span> <span class="n">SAVE_DISABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mPrivateFlags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG_SAVE_STATE_CALLED</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Parcelable</span> <span class="n">state</span> <span class="o">=</span> <span class="n">onSaveInstanceState</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">((</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_SAVE_STATE_CALLED</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
</span><span class='line'>                    <span class="s">&quot;Derived class did not call super.onSaveInstanceState()&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)</span>
</span><span class='line'>            <span class="c1">// + &quot;: &quot; + state);</span>
</span><span class='line'>            <span class="n">container</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">mID</span><span class="o">,</span> <span class="n">state</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>OK，重点来了，我们发现当id为空时，不会保存View的状态；整个保存状态分析就算完了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity生命周期（二）]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/01/activitysheng-ming-zhou-qi-(er-)/"/>
    <updated>2016-08-01T22:10:35+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/01/activitysheng-ming-zhou-qi-(er-)</id>
    <content type="html"><![CDATA[<p>这篇文章主要介绍下，异常情况Activity的生命周期，在这里说明这里的异常情况不是我们程序崩溃，而是指当系统配置发生变化或者内存不足时的情况。</p>

<!--more-->


<h4>一、系统内存不足</h4>

<p>先介绍一下Activity的优先级，如下:</p>

<ul>
<li>前台Activity，可以与用户进行交互，优先级最高</li>
<li>可见但不能进行交互的Activity，例如弹框中的Activity</li>
<li>后台Activity，不可见，优先级最低</li>
</ul>


<p>当系统的内存比较紧张时，会按照这个优先级来回收销毁Activity，在销毁Activity时，会调用onSaveInstance方法，保存当前Activity的状态</p>

<h4>二、系统配置发生变化</h4>

<p>当应用启动时，系统会根据系统的配置加载资源，当系统配置发生变化时，默认情况下，Activity会被销毁并重新创建，当然我们也可以阻止其销毁。当系统配置发生变化后，Activity会执行方法onPause、onStop、onDestory方法；</p>

<h4>三、阻止系统配置变化引起的销毁重建</h4>

<p>系统的配置有很多内容，当系统某项配置发生变化时我们不想Activity被销毁重建，我们可以在AndroidManifest.xml文件中设置Activity的configChanges属性，这样当此项配置发生变化时，就不会销毁重启了，而是调用Activity的onConfigurationChanged方法，举个🌰：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;.DemoActivity&quot;</span> <span class="na">android:configChanges=</span><span class="s">&quot;orientation|screenSize|</span>
</span><span class='line'><span class="s">keyboardHidden&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>只要你不想某项配置的变化导致Activity的销毁重启，你就可以配置进去，多个可以使用"|&ldquo;来增加</p>

<h4>三、数据的保存和恢复</h4>

<p>如果我们想在Activity异常销毁前存储一些数据怎么搞呢；别担心，在异常销毁时，会调用Activity的onSaveInstanceState方法，在此方法中我们可以保存当前Activity的状态等，当在启动调用onCreate方法时，注意onCreate方法有个Bundle参数，这个参数带有在onSaveInstanceState方法中保存的数据（具体是不是一个对象就不知道了，O(∩_∩)O哈哈~），这是我们就可以恢复数据了，除此之外系统还会调用onRestoreInstanceState方法</p>

<p><strong><em>注意：</em></strong>
当不是异常销毁重启时，并不会调用这个方法；在onCreate中使用参数恢复数据时，注意判断参数非空的情况，不是异常重启的情况，参数是为空的。</p>

<p><strong><em>调用时机：</em></strong>
onSaveInstanceState是在onStop之前，具体是在onPause之前还是在onPause之后，这个不确定；
onRestoreInstanceState方法是在onStart方法之后；</p>

<p><strong><em>系统恢复数据：</em></strong>
系统默认情况下，会帮我们保存Activity的状态，重启时恢复数据；在View中有和activity一样的方法onSaveInstanceState和onRestoreInstanceSate，具体保存那些数据可以看下其中的源码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity生命周期（一）]]></title>
    <link href="http://bgallon.github.io/blog/2016/07/31/activitysheng-ming-zhou-qi/"/>
    <updated>2016-07-31T22:45:43+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/07/31/activitysheng-ming-zhou-qi</id>
    <content type="html"><![CDATA[<p>经过两天的努力，搭建了Octopress,虽然有点老，但是感觉还不错，比起csdn这个超级方便，起码没有讨厌的广告，在我眼前晃来晃去，写起文章来，有种极客范；以前很少写文章，但是很多东西总是会慢慢忘记，就再此做个记录吧。开始今天的话题，Activity作为Android四大组件之一，是使用最为频繁的一种组件。下面主页解析一下Activity生命周期中的一些问题</p>

<!--more-->


<h4>一、生命周期方法</h4>

<p><img src="http://pic001.cnblogs.com/img/tea9/201008/2010080516521645.png" alt="Activity生命周期图" /><br>
<strong><em>onCreate：</em></strong>Activity生命周期中第一个方法，我们可以进行一些初始化工作，比如加载布局和数据等<br>
<strong><em>onStart：</em></strong>Activity已经可见了，但是还没有出现在前台，无法进行交互<br>
<strong><em>onResume:</em></strong>Activity出现在前台，用户可以与其进行交互<br>
<strong><em>onPause:</em></strong>Activity正在停止,在这个方法里主页不能进行耗时的处理，否则可能会影响新Activity的启动<br>
<strong><em>onStop:</em></strong>Activity即将停止<br>
<strong><em>onRestart:</em></strong>表示Activity正在重新启动，当当前Activity从不可见重新变为可见时调用。一般启动新的Activity又回来，会调动，或者按home键到桌面，又回到此Activity时调用。<br>
<strong><em>onDestroy:</em></strong>Activity正在销毁，一般点击返回键时触发<br></p>

<h4>二、Activity常见情形</h4>

<ul>
<li>第一次启动，onCreate->onStart->onResume</li>
<li>当启动新Activity或者点击Home回到桌面时，会继续调用onPause->onStop,但是当启动新的Activity是透明主题时，不会调用onStop方法</li>
<li>当用户回到Activity时，会继续调用onRestart->onStart->onResume</li>
<li>当用户点击返回键时，onPause->onStop->onDestory</li>
</ul>


<h4>三、特别说明</h4>

<ul>
<li>onPause和onResume,onStop和onStart是配对的，看起来onPause和onStop，onStart和onResume方法的含义是差不多的，其实这几个方法的描述重点不用，onPause和onResume是描述是否可以进行交互；而onStart和onStop来描述是否可见。</li>
<li>启动新的Activity时，onPause先进行调用，才会调用新的Activity的生命周期</li>
</ul>

]]></content>
  </entry>
  
</feed>
