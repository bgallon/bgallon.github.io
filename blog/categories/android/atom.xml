<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 狂奔的蜗牛]]></title>
  <link href="http://bgallon.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://bgallon.github.io/"/>
  <updated>2016-09-05T23:06:00+08:00</updated>
  <id>http://bgallon.github.io/</id>
  <author>
    <name><![CDATA[fishpan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[类加载器基础]]></title>
    <link href="http://bgallon.github.io/blog/2016/09/04/lei-jia-zai-qi-ji-chu/"/>
    <updated>2016-09-04T15:24:23+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/09/04/lei-jia-zai-qi-ji-chu</id>
    <content type="html"><![CDATA[<p>Java中有一个加载器是ClassLoader，但是Java中的加载器不能直接应用在Android上边；对于Android上的应用，虽然都是用Java开发，并且使用了标准的Java编译器编译出来的Class文件，但是最终的Apk文件却包含的是dex类型的文件，dex文件是将所需的所有Class文件重新打包；由于dex文件是一种优化过的class文件，所以并不能直接用ClassLoader加载, <a href="https://medium.com/@HeadFirstDroid/how-apps-are-built-and-run-on-the-android-runtime-art-c027f73edb09#.ul2b6736x">class到apk的过程</a>，使用ClassLoader会出现什么问题可以看下这篇文章<a href="http://blog.csdn.net/jiangwei0910410003/article/details/17679823"> Android中的动态加载机制</a>,为了在Android中能够动态加载，Android提供了两个DexClassLoader及PathClassLoader。</p>

<!--more-->


<h4>插件类</h4>

<pre><code class="java 插件类">public class Plugin {
    public String print(){
        Log.d("fishpan_log", "-----print-----");
        return "OK";
    }
}
</code></pre>

<p>接下来我们需要把插件类打包，并插件apk放到sdcard上。</p>

<h4>DexClassLoader</h4>

<pre><code class="java">private void dexClassLoader(){
        String sourceDir = "/sdcard/plugin-debug.apk";
        DexClassLoader clzzLoader = new DexClassLoader(sourceDir, getApplicationInfo().dataDir, null, getClassLoader());
        try {
            Class&lt;?&gt; clazz = clzzLoader.loadClass("com.fishpan.plugin.Plugin");
            Object object = clazz.newInstance();
            Method method = clazz.getMethod("print");
            Object result = method.invoke(object);
            Toast.makeText(this, "result:" + result, Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();
            e.printStackTrace();
        }
    }
</code></pre>

<p>因为在宿主apk中，是没有Plugin类，所以我们在宿主程序中不能直接使用，只能使用反射来进行。DexClassLoader构造参数有四个参数，第一个是dex或者apk文件地址；第二个是解压后dex文件的地址，这里我们使用宿主的dataDir;第三个是so文件路径，可以为空；第四个是父类加载器</p>

<h4>PathClassLoader</h4>

<pre><code class="java">private void pathClassLoader(){
        String sourceDir = "";
        try {
            PackageInfo packInfo = getPackageManager().getPackageInfo("com.fishpan.plugin", 0);
            sourceDir = packInfo.applicationInfo.sourceDir;
//            sourceDir = "/sdcard/plugin-debug.apk";   在安装的情况下,使用这种地址也是可以成功找到Class的
            PathClassLoader clzzLoader = new PathClassLoader(sourceDir, getClassLoader());
            Class&lt;?&gt; clazz = clzzLoader.loadClass("com.fishpan.plugin.Plugin");
            Object object = clazz.newInstance();
            Method method = clazz.getMethod("print");
            Object result = method.invoke(object);
            Toast.makeText(this, "result:" + result, Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();
            e.printStackTrace();
        }
    }
</code></pre>

<p>PathClassLoader和DexClassLoader的区别就是据说只能加载已经安装在Android系统内APK文件，但是我也做了实验，安装的情况下，apk文件的路径自己指定也能加载到Class，在实际使用过程中，还是使用DexClassLoader比较靠谱，</p>

<p>运行情况如下</p>

<p><img src="http://i2.buimg.com/567571/7d89c35fce163706.gif" alt="" /></p>

<p>另外这里使用插件类，都是使用反射完成的，我们可以定义一个公共的接口，这样在插件apk和宿主apk里放入接口，这样就不用使用反射了，用起来就比较简单和容易了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代理模式]]></title>
    <link href="http://bgallon.github.io/blog/2016/09/03/dai-li-mo-shi/"/>
    <updated>2016-09-03T14:59:28+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/09/03/dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>

<!--more-->


<p><img src="http://i1.piimg.com/567571/a74ac82fd02cddc9.gif" alt="" /></p>

<p>Subject:委托对象和代理对象的共同接口</p>

<p>RealSubject:委托对象</p>

<p>Proxy:代理对象</p>

<h4>代理实现分类：</h4>

<ul>
<li><p>静态代理</p>

<p>  代理类是在编译时就实现好了。</p></li>
<li><p>动态代理</p>

<p>  动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。</p></li>
</ul>


<h4>静态代理</h4>

<pre><code class="java 公共接口">public interface Subject {
    public void request();
}
</code></pre>

<pre><code class="java 委托对象">
public class RealSubject implements Subject {

    @Override
    public void request() {
        System.out.println("request");
    }

}
</code></pre>

<pre><code class="java 代理对象">public class Proxy implements Subject{
    private Subject mSubject;

    public Proxy(Subject subject){
        mSubject = subject;
    }

    @Override
    public void request() {
        System.out.println("start request");
        if(null != mSubject){
            mSubject.request();
        }
        System.out.println("end request");
    }

}
</code></pre>

<p>静态代理类优缺点</p>

<p>优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</p>

<p>缺点：</p>

<ul>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
</ul>


<h4>动态代理</h4>

<p>实现动态代理模式，首先我们需要创建一个调度器，只需实现InvocationHandler接口即可</p>

<pre><code class="java 调度器">public class SubjectHandler implements InvocationHandler{
    private Object delegate;

    public SubjectHandler(Object delegate) {
        this.delegate = delegate;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        System.out.println("start invoke");
        Object result = method.invoke(delegate, args);
        System.out.println("end invoke");
        return result; 
    }
}
</code></pre>

<pre><code class="java">Subject delegate = new RealSubject();
SubjectHandler handler = new SubjectHandler(delegate);
Subject proxy = (Subject)java.lang.reflect.Proxy.newProxyInstance(  
    delegate.getClass().getClassLoader(),   
    delegate.getClass().getInterfaces(),   
    handler);  
proxy.request();
</code></pre>

<p>优点：
动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。</p>

<p>缺点：
无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 Java 中本质上就行不通。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPC机制-Binder]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/14/ipcji-zhi-binder/"/>
    <updated>2016-08-14T10:43:45+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/14/ipcji-zhi-binder</id>
    <content type="html"><![CDATA[<p>Binder是进程间通讯的一种方式，Android开发中，Binder主要用于Service中，其中普通的service不涉及设计进程间通讯，我这里看下AIDL方式，看下整个的调用过程</p>

<!--more-->


<p>首先我们先创建aidl文件IDemoManager.aidl,<strong><em>注意</em></strong>在Android studio中使用aidl,需要单独放在一个文件夹下，名称为aidl,和java同目录，如图</p>

<p><img src="http://i1.piimg.com/567571/e946c4c0e24e3645.jpg" alt="" /></p>

<p>内容如下：</p>

<pre><code class="java">
package com.xxx.xxx;

interface IDemoManager {
    void add(int a, int b);
}
</code></pre>

<p>然后进行编译，如下图</p>

<p><img src="http://i1.piimg.com/567571/38daf5235fd2f2e9.jpg" alt="" /></p>

<p>可以在build中发现自动生成的代码，这就是aidl要做的事情，工具根据我们写的aidl文件，编程成代码，当然你也可以不写aidl文件，自己写代码</p>

<p><img src="http://i1.piimg.com/567571/2896af883b845c00.jpg" alt="" /></p>

<p>下面我就来研究一下为我们生成的代码，这个才是最关键</p>

<pre><code class="java">
    public interface IDemoManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.fishpan.appliactions.IDemoManager {
        private static final java.lang.String DESCRIPTOR = "com.fishpan.appliactions.IDemoManager";

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.fishpan.appliactions.IDemoManager interface,
         * generating a proxy if needed.
         */
        public static com.fishpan.appliactions.IDemoManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.fishpan.appliactions.IDemoManager))) {
                return ((com.fishpan.appliactions.IDemoManager) iin);
            }
            return new com.fishpan.appliactions.IDemoManager.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_add: {
                    data.enforceInterface(DESCRIPTOR);
                    int _arg0;
                    _arg0 = data.readInt();
                    int _arg1;
                    _arg1 = data.readInt();
                    int _result = this.add(_arg0, _arg1);
                    reply.writeNoException();
                    reply.writeInt(_result);
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.fishpan.appliactions.IDemoManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public int add(int a, int b) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                int _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeInt(a);
                    _data.writeInt(b);
                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.readInt();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
        }

        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    }

    public int add(int a, int b) throws android.os.RemoteException;
}
</code></pre>

<p>自动生成的代码有点乱，我们可以把它给格式化一下，可以看到编译工具为我们生成了一个接口IDemoManager,继承于IInterface，啥事也没干；一个add方法，一个静态的内部抽象类，继承与Binder，实现IDemoManager本身，我们来详细看看他的每一部分</p>

<ul>
<li>DESCRIPTOR Binder的唯一标识</li>
<li>asInterface 用于将服务端的Binder对象转换成客户端所需要的aidl接口类型的对象，注意我们可以根据代码看出，他有两个地方有return，第一个其实是当客户端和服务端属于同一个进程时，返回自己本身，第二个是返回了一个代理对象</li>
<li>asBinder 用于返回当前Binder对象</li>
<li>onTransact 这个方法运行在<strong><em>服务端</em></strong>，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交有此方法。服务端通过code，确定客户端要执行什么方法，从data获取参数，然后指定目标方法；执行完毕后就像reply中写入返回值(如果有返回值)</li>
<li>Proxy#add 此方法运行在客户端，当客户端调用此方法时，会输入型参数write进<em>data，输出型参数write进</em>reply,紧接着会调用transact方法来发起RPC请求，当前线程挂起；服务端的onTransact方法被调用，调用结束后，返回数据会在_reply中。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FramtentPagerAdapter和FramgentStatePagerAdapter的区别]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/14/framtentpageradapterhe-framgentstatepageradapterde-qu-bie/"/>
    <updated>2016-08-14T10:43:45+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/14/framtentpageradapterhe-framgentstatepageradapterde-qu-bie</id>
    <content type="html"><![CDATA[<p>平时还真的很少关心FramgmentStatsPagerAdpater和FragmentPagerAdapter，以前只是两者有区别，但是不是很清楚到底有啥区别，今天就特别写了一个demo，来研究了下两者的区别</p>

<!--more-->


<h4>FragmentStateViewPager</h4>

<p>很多资料都在说：这个适配器是实现多个fragment界面的滑动时非常有效，当Fragment对用户不可见时，整个fragment会被销毁，只会保存fragment的状态，更适合当fragment比较多的时候使用，而且消耗的资源更少:我写了段代码在Fragment的onCreate，onCreateView，onDestory,onDestoryView方法中打印日志，观察它的生命周期：
我进入activity一直滑动到第三个Fragment为止，日志如下</p>

<p><img src="http://i2.buimg.com/567571/235e5452e84d1730.jpg" alt="" /></p>

<p>通过日志我们可以发现：</p>

<ul>
<li>当进入Activity时，会创建两个Fragment</li>
<li>向右滑一下到1，创建第三个fragment</li>
<li>再向右滑一下到2，这个时候不仅仅都创建了一个fragment，而且还销毁了第一个fragment</li>
<li>再向右滑一下到3，这个时候同样，创建一个销毁一个</li>
</ul>


<p>可见，默认情况下没有设置viewPager的offscreenPageLimit属性时，当前fragment的保留总数最多是三个，及当前选中的fragment和选中左右两个fragment（可能没有），其它的fragment就会被销毁，并且还会保留销毁的fragment的状态，待重建时进行恢复（onSaveInstanceState方法），所以我觉得上边说的当fragment不可见时就会被销毁时错误的，严格的来讲应该是在缓存fragment之外的fragment会被销毁，<strong><em>并不是不可见就会被销毁</em></strong></p>

<h4>FragmentViewPager</h4>

<p>这个是ViewPager+Fragment常用的适配器，我们经常会使用，虽然常见我为了弄清楚有啥区别，同样做了一个实验，在生命周期打印日志，操作步骤和上边的FragmentStateViewPager一致，日志如下:</p>

<p><img src="http://i1.buimg.com/567571/3828d9ebb9dc03f8.jpg" alt="" /></p>

<p>从日志中我们可以发现，基本上和FragmentStateViewPager类似，但是其中缺少fragment销毁的操作，这就是他们的区别，fragmentStatePagerAdapter会把缓存之外的fragment销毁，而FragmentViewPager则不会，还会进行保留。</p>

<h4>总结</h4>

<p>相比之下，FragmentViewPager会更加流畅，而FragmentStateViewPager会更节省资源，对于fragment比较多的情况下我们可以使用FragmentStateViewPager，较少时使用FragmentViewPager更为妥当一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPC机制-多进程]]></title>
    <link href="http://bgallon.github.io/blog/2016/08/13/ipcji-zhi-duo-jin-cheng/"/>
    <updated>2016-08-13T15:03:24+08:00</updated>
    <id>http://bgallon.github.io/blog/2016/08/13/ipcji-zhi-duo-jin-cheng</id>
    <content type="html"><![CDATA[<p>一个应用默认只有一个进程，这个进程的名字就是应用的包名，进程是系统分配资源和调度的基本单位，每个进程都要有自己的资源和空间，其它程序不能任意访问当前进程的空间，系统给每个进程分配的空间会有限制。</p>

<!--more-->


<p>但是这都是默认情况下的事情，伟大的程序员是不会屈服一个进程的，我就弄出多个进程来玩玩；Android系统也是蛮大方的，你要多个，好，我来满足你，你可以指定一些组件运行在不同的进程中，只需指定组件的：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span>android:process
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>设置process属性的方式有两种：</p>

<ul>
<li>android:process=&ldquo;:remote&rdquo;,以冒号开头，冒号后边的字符是可以随意指定的。当然这只是一种缩写形式，全称应该是：包名+&ldquo;:remote"；这种形式表示该进程为当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中。</li>
<li>android:process=&ldquo;xxx.xxx"表示运行在以这个名称的全局进程中，其它应用可以通过shareUID和他跑在同一个进程中；</li>
</ul>


<p>虽然开启多进程是非常非常简单，但是有很多坑，一不小心就掉进去了：</p>

<ul>
<li>Application多次创建，启动多进程的生活，Application会被多次创建，在application中我们可以通过当前进程名字，来初始化数据，防止无必要的初始化</li>
<li>静态成员失效，各个进程是单独分配的内存，所以这里的静态成员变量将会失效</li>
<li>文件共享，多个进程同时访问一个文件时，可能造成文件损坏丢失等情况</li>
<li>断点调试的问题。调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试</li>
</ul>

]]></content>
  </entry>
  
</feed>
